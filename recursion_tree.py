# @Time    : 2019/2/13 10:48
# @Author  : Xu Huipeng
# @Blog    : https://brycexxx.github.io/

"""
1 个细胞的生命周期是 3 小时，1 小时分裂一次。n 小时后容器内有多少细胞
题目来源：https://time.geekbang.org/column/article/69388

分析：

这里假设经过三个小时的细胞分裂后再死亡。
细胞分裂的方式：根据题意，细胞的生命周期是三个小时，一个小时后，第一个细胞分裂，此时细胞总数变成 2，
但是这两个细胞的生存时间是不一样的，如果都当成新生细胞即存活时间为 0，那么给定的 3小时生命周期也就
没意义了，所以这个时候其中一个细胞的生存时间变成了 1，另外一个刚分裂出来的是 0，下面简单表示一下
分裂进程（-1 表示死亡）：

时间 细胞状态 (生存时间)             细胞总数
 0   0                                1
 1   1 0                              2
 2   2 1 0 0                          4
 3  -1 2 1 1 0 0 0 0                  7
 4  -1 2 2 1 1 1 1 0 0 0 0 0 0 0      13
 5  -1 -1 2 2 2 2 1 1 1 1 1 1 1
     0 0 0 0 0 0 0 0 0 0 0 0 0        24
 ... .......................          ....

f0 = 1
f1 = 2
f2 = 4
f3 = 7
可以发现到第四个小时的时候，规律出来了，在第四个小时死亡的细胞是三小时前也就是第一个小时的时候同时出生的细胞，
而在第一个小时同时出生的细胞数等于第一个小时前一个小时的细胞总数
所以有递推式：f(n) = 2 * f(n - 1) - f(n - 4)

复杂度的分析根据递推式 f(n) = 2 * f(n - 1) - f(n - 4) 以及老师对斐波那契的分析，
在细胞分裂里，最短路径是 n / 4，最长路径是 n，
如果路径长度都为 n / 4，那么总时间消耗为：1 + 2 + 2^2 + ..... + 2^(n/4 - 1) = 2^(n/4) - 1
路径长度为 n 时和斐波那契一致，即 2^n - 1
所以时间复杂度介于 O(2^n) 和 O(2^(n/4)) 之间
"""


def cell_division(t: int) -> int:
    if t == 0:
        return 1
    elif t == 1:
        return 2
    elif t == 2:
        return 4
    elif t == 3:
        return 7
    else:
        return 2 * cell_division(t - 1) - cell_division(t - 4)


if __name__ == "__main__":
    print(cell_division(5))
